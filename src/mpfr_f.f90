! Inspired by:
! https://github.com/tkoenig1/FMPFR
! but without any allocatable components.
! It is expected that all MPFR variables are explicitly cleared after the last use,
! and that the arithmetic is done by calling the C functions directly, instead of
! having overloaded arithmetic operators (except for assignments and comparisons).
MODULE MPFR_F
  USE, INTRINSIC :: IEEE_ARITHMETIC
  USE, INTRINSIC :: ISO_C_BINDING
  USE, INTRINSIC :: ISO_FORTRAN_ENV
  IMPLICIT NONE

  INTEGER, PARAMETER :: MPFR_PREC_KIND = c_long
  INTEGER, PARAMETER :: MPFR_SIGN_KIND = c_int
  INTEGER, PARAMETER :: MPFR_EXP_KIND = c_long
  INTEGER, PARAMETER :: MPFR_RND_KIND = c_int

  INTEGER(KIND=MPFR_PREC_KIND), PARAMETER :: MPFR_PREC_MIN = 1_MPFR_PREC_KIND
  INTEGER(KIND=MPFR_PREC_KIND), PARAMETER :: MPFR_PREC_MAX = HUGE(MPFR_PREC_MAX) - 256_MPFR_PREC_KIND

  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDN = 0_MPFR_RND_KIND
  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDZ = 1_MPFR_RND_KIND
  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDU = 2_MPFR_RND_KIND
  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDD = 3_MPFR_RND_KIND
  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDA = 4_MPFR_RND_KIND
  INTEGER(KIND=MPFR_RND_KIND), PARAMETER :: MPFR_RNDF = 5_MPFR_RND_KIND

  INTEGER(KIND=c_int), PARAMETER, PRIVATE :: TAG_NULL = 0_c_int
  INTEGER(KIND=c_int), PARAMETER, PRIVATE :: TAG_INIT = 1_c_int

  INTEGER(KIND=MPFR_PREC_KIND), PRIVATE :: MPFR_PREC_DEFAULT = 113_MPFR_PREC_KIND
  INTEGER(KIND=MPFR_RND_KIND), PRIVATE :: MPFR_RND_DEFAULT = MPFR_RNDN

  TYPE, BIND(C) :: MPFR_T
     INTEGER(KIND=MPFR_PREC_KIND) :: MPFR_PREC = 0_MPFR_PREC_KIND
     INTEGER(KIND=MPFR_SIGN_KIND) :: MPFR_SIGN = 0_MPFR_SIGN_KIND
     ! HACK: since the sign is an int, there is a 4-byte hole
     ! here, that can be filled with additional information
     INTEGER(KIND=c_int) :: TAG = TAG_NULL
     INTEGER(KIND=MPFR_EXP_KIND) :: MPFR_EXP = 0_MPFR_EXP_KIND
     INTEGER(KIND=c_intptr_t) :: MPFR_D = 0_c_intptr_t
  END TYPE MPFR_T

  INTERFACE ASSIGNMENT(=)
     MODULE PROCEDURE MPFR_ASSIGN_M_M
     MODULE PROCEDURE MPFR_ASSIGN_M_I
     MODULE PROCEDURE MPFR_ASSIGN_M_S
     MODULE PROCEDURE MPFR_ASSIGN_M_D
#ifdef __GFORTRAN__
     MODULE PROCEDURE MPFR_ASSIGN_M_X
#endif
     MODULE PROCEDURE MPFR_ASSIGN_M_Q
     MODULE PROCEDURE MPFR_ASSIGN_I_M
     MODULE PROCEDURE MPFR_ASSIGN_S_M
     MODULE PROCEDURE MPFR_ASSIGN_D_M
#ifdef __GFORTRAN__
     MODULE PROCEDURE MPFR_ASSIGN_X_M
#endif
     MODULE PROCEDURE MPFR_ASSIGN_Q_M
  END INTERFACE ASSIGNMENT(=)

  INTERFACE OPERATOR(.LT.)
     MODULE PROCEDURE MPFR_CMP_LT
  END INTERFACE OPERATOR(.LT.)
  INTERFACE OPERATOR(.LE.)
     MODULE PROCEDURE MPFR_CMP_LE
  END INTERFACE OPERATOR(.LE.)
  INTERFACE OPERATOR(.EQ.)
     MODULE PROCEDURE MPFR_CMP_EQ
  END INTERFACE OPERATOR(.EQ.)
  INTERFACE OPERATOR(.NE.)
     MODULE PROCEDURE MPFR_CMP_NE
  END INTERFACE OPERATOR(.NE.)
  INTERFACE OPERATOR(.GE.)
     MODULE PROCEDURE MPFR_CMP_GE
  END INTERFACE OPERATOR(.GE.)
  INTERFACE OPERATOR(.GT.)
     MODULE PROCEDURE MPFR_CMP_GT
  END INTERFACE OPERATOR(.GT.)

  INTERFACE
     PURE SUBROUTINE MPFR_SET_NAN(X) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(INOUT) :: X
     END SUBROUTINE MPFR_SET_NAN
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE MPFR_SET_INF(X, S) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(INOUT) :: X
       INTEGER(KIND=c_int), INTENT(IN), VALUE :: S
     END SUBROUTINE MPFR_SET_INF
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE MPFR_SET_ZERO(X, S) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(INOUT) :: X
       INTEGER(KIND=c_int), INTENT(IN), VALUE :: S
     END SUBROUTINE MPFR_SET_ZERO
  END INTERFACE

  INTERFACE
     PURE FUNCTION MPFR_GET_SI(RHS, RND) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: RHS
       INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
       INTEGER(KIND=c_long) :: MPFR_GET_SI
     END FUNCTION MPFR_GET_SI
  END INTERFACE
  INTERFACE
     PURE FUNCTION MPFR_GET_FLT(RHS, RND) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: RHS
       INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
       REAL(KIND=REAL32) :: MPFR_GET_FLT
     END FUNCTION MPFR_GET_FLT
  END INTERFACE
  INTERFACE
     PURE FUNCTION MPFR_GET_D(RHS, RND) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: RHS
       INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
       REAL(KIND=REAL64) :: MPFR_GET_D
     END FUNCTION MPFR_GET_D
  END INTERFACE
#ifdef __GFORTRAN__
  INTERFACE
     PURE FUNCTION MPFR_GET_LD(RHS, RND) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: RHS
       INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
       REAL(KIND=c_long_double) :: MPFR_GET_LD
     END FUNCTION MPFR_GET_LD
  END INTERFACE
#endif
  INTERFACE
     PURE FUNCTION MPFR_GET_FLOAT128(RHS, RND) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: RHS
       INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
       REAL(KIND=REAL128) :: MPFR_GET_FLOAT128
     END FUNCTION MPFR_GET_FLOAT128
  END INTERFACE

  INTERFACE
     PURE FUNCTION MPFR_CMP(L, R) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: L, R
       INTEGER(KIND=c_int) :: MPFR_CMP
     END FUNCTION MPFR_CMP
  END INTERFACE
  INTERFACE
     PURE FUNCTION MPFR_CMP_SI(L, R) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: L
       INTEGER(KIND=c_long), INTENT(IN), VALUE :: R
       INTEGER(KIND=c_int) :: MPFR_CMP_SI
     END FUNCTION MPFR_CMP_SI
  END INTERFACE
  INTERFACE
     PURE FUNCTION MPFR_CMP_D(L, R) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: L
       REAL(KIND=c_double), INTENT(IN), VALUE :: R
       INTEGER(KIND=c_int) :: MPFR_CMP_D
     END FUNCTION MPFR_CMP_D
  END INTERFACE
#ifdef __GFORTRAN__
  INTERFACE
     PURE FUNCTION MPFR_CMP_LD(L, R) BIND(C)
       IMPORT
       IMPLICIT NONE
       TYPE(MPFR_T), INTENT(IN) :: L
       REAL(KIND=c_long_double), INTENT(IN), VALUE :: R
       INTEGER(KIND=c_int) :: MPFR_CMP_LD
     END FUNCTION MPFR_CMP_LD
  END INTERFACE
#endif

CONTAINS

  ! MUST be called before all other subroutines from this module.
  FUNCTION MPFR_INITIALIZE(P, R)
    IMPLICIT NONE
    INTERFACE
       SUBROUTINE MPFR_SET_DEFAULT_PREC(P) BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_PREC_KIND), INTENT(IN), VALUE :: P
       END SUBROUTINE MPFR_SET_DEFAULT_PREC
    END INTERFACE
    INTERFACE
       SUBROUTINE MPFR_SET_DEFAULT_ROUNDING_MODE(R) BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: R
       END SUBROUTINE MPFR_SET_DEFAULT_ROUNDING_MODE
    END INTERFACE
    INTERFACE
       PURE FUNCTION MPFR_GET_EMIN_MIN() BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_EXP_KIND) :: MPFR_GET_EMIN_MIN
       END FUNCTION MPFR_GET_EMIN_MIN
    END INTERFACE
    INTERFACE
       PURE FUNCTION MPFR_GET_EMAX_MAX() BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_EXP_KIND) :: MPFR_GET_EMAX_MAX
       END FUNCTION MPFR_GET_EMAX_MAX
    END INTERFACE
    INTERFACE
       FUNCTION MPFR_SET_EMIN(E) BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_EXP_KIND), INTENT(IN), VALUE :: E
         INTEGER(KIND=c_int) :: MPFR_SET_EMIN
       END FUNCTION MPFR_SET_EMIN
    END INTERFACE
    INTERFACE
       FUNCTION MPFR_SET_EMAX(E) BIND(C)
         IMPORT
         IMPLICIT NONE
         INTEGER(KIND=MPFR_EXP_KIND), INTENT(IN), VALUE :: E
         INTEGER(KIND=c_int) :: MPFR_SET_EMAX
       END FUNCTION MPFR_SET_EMAX
    END INTERFACE
    INTEGER(KIND=MPFR_PREC_KIND), INTENT(IN), OPTIONAL :: P
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: R
    INTEGER :: MPFR_INITIALIZE
    MPFR_INITIALIZE = 0
    IF (PRESENT(R)) THEN
       IF ((R .GE. MPFR_RNDN) .AND. (R .LE. MPFR_RNDF)) THEN
          MPFR_RND_DEFAULT = R
       ELSE ! error
          MPFR_INITIALIZE = -2
       END IF
    END IF
    IF (MPFR_INITIALIZE .NE. 0) RETURN
    IF (PRESENT(P)) THEN
       IF ((P .GE. MPFR_PREC_MIN) .AND. (P .LE. MPFR_PREC_MAX)) THEN
          MPFR_PREC_DEFAULT = P
       ELSE ! error
          MPFR_INITIALIZE = -1
       END IF
    END IF
    IF (MPFR_INITIALIZE .NE. 0) RETURN
    MPFR_INITIALIZE = INT(MPFR_SET_EMIN(MPFR_GET_EMIN_MIN()))
    IF (MPFR_INITIALIZE .NE. 0) RETURN
    MPFR_INITIALIZE = INT(MPFR_SET_EMAX(MPFR_GET_EMAX_MAX()))
    IF (MPFR_INITIALIZE .NE. 0) RETURN
    CALL MPFR_SET_DEFAULT_PREC(MPFR_PREC_DEFAULT)
    CALL MPFR_SET_DEFAULT_ROUNDING_MODE(MPFR_RND_DEFAULT)
  END FUNCTION MPFR_INITIALIZE
  SUBROUTINE MPFR_FINALIZE()
    IMPLICIT NONE
    INTERFACE
       SUBROUTINE MPFR_FREE_CACHE() BIND(C)
         IMPORT
         IMPLICIT NONE
       END SUBROUTINE MPFR_FREE_CACHE
    END INTERFACE
    CALL MPFR_FREE_CACHE()
  END SUBROUTINE MPFR_FINALIZE

  PURE SUBROUTINE MPFR_CLEAR_M(M)
    IMPLICIT NONE
    INTERFACE
       PURE SUBROUTINE MPFR_CLEAR(M) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(MPFR_T), INTENT(INOUT) :: M
       END SUBROUTINE MPFR_CLEAR
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT) :: M
    CALL MPFR_CLEAR(M)
#ifndef NDEBUG
    M%MPFR_PREC = 0_MPFR_PREC_KIND
    M%MPFR_SIGN = 0_MPFR_SIGN_KIND
#endif
    M%TAG = TAG_NULL
#ifndef NDEBUG
    M%MPFR_EXP = 0_MPFR_EXP_KIND
    M%MPFR_D = 0_c_intptr_t
#endif
  END SUBROUTINE MPFR_CLEAR_M
  PURE SUBROUTINE MPFR_INIT_M(LHS, P)
    IMPLICIT NONE
    INTERFACE
       PURE SUBROUTINE MPFR_INIT2(M, P) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(MPFR_T), INTENT(INOUT) :: M
         INTEGER(KIND=MPFR_PREC_KIND), INTENT(IN), VALUE :: P
       END SUBROUTINE MPFR_INIT2
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT) :: LHS
    INTEGER(KIND=MPFR_PREC_KIND), INTENT(IN), OPTIONAL :: P
    IF (LHS%TAG .NE. TAG_NULL) CALL MPFR_CLEAR_M(LHS)
    IF (PRESENT(P)) THEN
       CALL MPFR_INIT2(LHS, P)
    ELSE ! default
       CALL MPFR_INIT2(LHS, MPFR_PREC_DEFAULT)
    END IF
#ifndef NDEBUG
    CALL MPFR_SET_NAN(LHS)
#endif
    LHS%TAG = TAG_INIT
  END SUBROUTINE MPFR_INIT_M
  PURE SUBROUTINE MPFR_SET_M(LHS, RHS, RND)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS, RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET
       END FUNCTION MPFR_SET
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    TYPE(MPFR_T), INTENT(IN), TARGET :: RHS
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    IF (LHS%TAG .EQ. TAG_NULL) THEN
       IF (RHS%TAG .EQ. TAG_NULL) THEN
          RETURN
       ELSE ! RHS initialized
          CALL MPFR_INIT_M(LHS, RHS%MPFR_PREC)
       END IF
    END IF
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       CALL MPFR_CLEAR_M(LHS)
    ELSE IF (PRESENT(RND)) THEN
       LHS%TAG = MAX(MPFR_SET(C_LOC(LHS), C_LOC(RHS), RND), RHS%TAG)
    ELSE ! default
       LHS%TAG = MAX(MPFR_SET(C_LOC(LHS), C_LOC(RHS), MPFR_RND_DEFAULT), RHS%TAG)
    END IF
  END SUBROUTINE MPFR_SET_M
  PURE SUBROUTINE MPFR_SWAP_M(X, Y)
    IMPLICIT NONE
    INTERFACE
       PURE SUBROUTINE MPFR_SWAP(X, Y) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(MPFR_T), INTENT(INOUT) :: X, Y
       END SUBROUTINE MPFR_SWAP
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT) :: X, Y
    INTEGER(KIND=c_int) :: XT, YT
    XT = X%TAG
    YT = Y%TAG
    CALL MPFR_SWAP(X, Y)
    X%TAG = YT
    Y%TAG = XT
  END SUBROUTINE MPFR_SWAP_M

  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_M(LHS, RHS)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(INOUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    CALL MPFR_SET_M(LHS, RHS)
  END SUBROUTINE MPFR_ASSIGN_M_M
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_I(LHS, RHS)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET_SI(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET_SI
       END FUNCTION MPFR_SET_SI
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    INTEGER(KIND=c_long), INTENT(IN) :: RHS
    IF (LHS%TAG .EQ. TAG_NULL) CALL MPFR_INIT_M(LHS)
    LHS%TAG = MAX(MPFR_SET_SI(C_LOC(LHS), RHS, MPFR_RND_DEFAULT), LHS%TAG)
  END SUBROUTINE MPFR_ASSIGN_M_I
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_S(LHS, RHS)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET_FLT(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS
         REAL(KIND=REAL32), INTENT(IN), VALUE :: RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET_FLT
       END FUNCTION MPFR_SET_FLT
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    REAL(KIND=REAL32), INTENT(IN) :: RHS
    IF (LHS%TAG .EQ. TAG_NULL) CALL MPFR_INIT_M(LHS)
    LHS%TAG = MAX(MPFR_SET_FLT(C_LOC(LHS), RHS, MPFR_RND_DEFAULT), LHS%TAG)
  END SUBROUTINE MPFR_ASSIGN_M_S
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_D(LHS, RHS)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET_D(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS
         REAL(KIND=REAL64), INTENT(IN), VALUE :: RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET_D
       END FUNCTION MPFR_SET_D
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    REAL(KIND=REAL64), INTENT(IN) :: RHS
    IF (LHS%TAG .EQ. TAG_NULL) CALL MPFR_INIT_M(LHS)
    LHS%TAG = MAX(MPFR_SET_D(C_LOC(LHS), RHS, MPFR_RND_DEFAULT), LHS%TAG)
  END SUBROUTINE MPFR_ASSIGN_M_D
#ifdef __GFORTRAN__
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_X(LHS, RHS)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET_LD(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS
         REAL(KIND=c_long_double), INTENT(IN), VALUE :: RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET_LD
       END FUNCTION MPFR_SET_LD
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    REAL(KIND=c_long_double), INTENT(IN) :: RHS
    IF (LHS%TAG .EQ. TAG_NULL) CALL MPFR_INIT_M(LHS)
    LHS%TAG = MAX(MPFR_SET_LD(C_LOC(LHS), RHS, MPFR_RND_DEFAULT), LHS%TAG)
  END SUBROUTINE MPFR_ASSIGN_M_X
#endif
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_M_Q(LHS, RHS)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SET_FLOAT128(LHS, RHS, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: LHS
         REAL(KIND=REAL128), INTENT(IN), VALUE :: RHS
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SET_FLOAT128
       END FUNCTION MPFR_SET_FLOAT128
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: LHS
    REAL(KIND=REAL128), INTENT(IN) :: RHS
    IF (LHS%TAG .EQ. TAG_NULL) CALL MPFR_INIT_M(LHS)
    LHS%TAG = MAX(MPFR_SET_FLOAT128(C_LOC(LHS), RHS, MPFR_RND_DEFAULT), LHS%TAG)
  END SUBROUTINE MPFR_ASSIGN_M_Q
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_I_M(LHS, RHS)
    IMPLICIT NONE
    INTEGER(KIND=c_long), INTENT(OUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       LHS = -HUGE(LHS) - 1_c_long
    ELSE ! RHS initialized
       LHS = MPFR_GET_SI(RHS, MPFR_RND_DEFAULT)
    END IF
  END SUBROUTINE MPFR_ASSIGN_I_M
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_S_M(LHS, RHS)
    IMPLICIT NONE
    REAL(KIND=REAL32), INTENT(OUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       LHS = IEEE_VALUE(LHS, IEEE_SIGNALING_NAN)
    ELSE ! RHS initialized
       LHS = MPFR_GET_FLT(RHS, MPFR_RND_DEFAULT)
    END IF
  END SUBROUTINE MPFR_ASSIGN_S_M
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_D_M(LHS, RHS)
    IMPLICIT NONE
    REAL(KIND=REAL64), INTENT(OUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       LHS = IEEE_VALUE(LHS, IEEE_SIGNALING_NAN)
    ELSE ! RHS initialized
       LHS = MPFR_GET_D(RHS, MPFR_RND_DEFAULT)
    END IF
  END SUBROUTINE MPFR_ASSIGN_D_M
#ifdef __GFORTRAN__
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_X_M(LHS, RHS)
    IMPLICIT NONE
    REAL(KIND=c_long_double), INTENT(OUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       LHS = IEEE_VALUE(LHS, IEEE_SIGNALING_NAN)
    ELSE ! RHS initialized
       LHS = MPFR_GET_LD(RHS, MPFR_RND_DEFAULT)
    END IF
  END SUBROUTINE MPFR_ASSIGN_X_M
#endif
  ELEMENTAL SUBROUTINE MPFR_ASSIGN_Q_M(LHS, RHS)
    IMPLICIT NONE
    REAL(KIND=REAL128), INTENT(OUT) :: LHS
    TYPE(MPFR_T), INTENT(IN) :: RHS
    IF (RHS%TAG .EQ. TAG_NULL) THEN
       LHS = IEEE_VALUE(LHS, IEEE_SIGNALING_NAN)
    ELSE ! RHS initialized
       LHS = MPFR_GET_FLOAT128(RHS, MPFR_RND_DEFAULT)
    END IF
  END SUBROUTINE MPFR_ASSIGN_Q_M

  ELEMENTAL FUNCTION MPFR_CMP_LT(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_LT
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_LT = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_LT = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_LT = (MPFR_CMP(L, R) .LT. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_LT
  ELEMENTAL FUNCTION MPFR_CMP_LE(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_LE
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_LE = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_LE = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_LE = (MPFR_CMP(L, R) .LE. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_LE
  ELEMENTAL FUNCTION MPFR_CMP_EQ(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_EQ
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_EQ = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_EQ = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_EQ = (MPFR_CMP(L, R) .EQ. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_EQ
  ELEMENTAL FUNCTION MPFR_CMP_NE(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_NE
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_NE = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_NE = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_NE = (MPFR_CMP(L, R) .NE. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_NE
  ELEMENTAL FUNCTION MPFR_CMP_GE(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_GE
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_GE = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_GE = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_GE = (MPFR_CMP(L, R) .GE. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_GE
  ELEMENTAL FUNCTION MPFR_CMP_GT(L, R)
    IMPLICIT NONE
    TYPE(MPFR_T), INTENT(IN) :: L, R
    LOGICAL :: MPFR_CMP_GT
    IF (L%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_GT = .FALSE.
    ELSE IF (R%TAG .EQ. TAG_NULL) THEN
       MPFR_CMP_GT = .FALSE.
    ELSE ! L and R initialized
       MPFR_CMP_GT = (MPFR_CMP(L, R) .GT. 0_c_int)
    END IF
  END FUNCTION MPFR_CMP_GT

  ! TODO: insert here the operations defined by mpfr_f.sh

  PURE SUBROUTINE MPFR_ABS_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_ABS(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_ABS
       END FUNCTION MPFR_ABS
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_ABS(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_ABS(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_ABS_F
  PURE SUBROUTINE MPFR_CBRT_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_CBRT(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_CBRT
       END FUNCTION MPFR_CBRT
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_CBRT(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_CBRT(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_CBRT_F
  PURE SUBROUTINE MPFR_NEG_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_NEG(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_NEG
       END FUNCTION MPFR_NEG
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_NEG(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_NEG(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_NEG_F
  PURE SUBROUTINE MPFR_REC_SQRT_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_REC_SQRT(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_REC_SQRT
       END FUNCTION MPFR_REC_SQRT
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_REC_SQRT(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_REC_SQRT(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_REC_SQRT_F
  PURE SUBROUTINE MPFR_SQR_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SQR(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SQR
       END FUNCTION MPFR_SQR
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SQR(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_SQR(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SQR_F
  PURE SUBROUTINE MPFR_SQRT_F(ROP, OP, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SQRT(ROP, OP, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SQRT
       END FUNCTION MPFR_SQRT
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SQRT(C_LOC(ROP), C_LOC(OP), RND)
       ELSE ! default rounding
          INFO = MPFR_SQRT(C_LOC(ROP), C_LOC(OP), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SQRT_F
  PURE SUBROUTINE MPFR_ADD_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_ADD(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_ADD
       END FUNCTION MPFR_ADD
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_ADD(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_ADD(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_ADD_F
  PURE SUBROUTINE MPFR_DIV_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_DIV(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_DIV
       END FUNCTION MPFR_DIV
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_DIV(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_DIV(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_DIV_F
  PURE SUBROUTINE MPFR_HYPOT_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_HYPOT(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_HYPOT
       END FUNCTION MPFR_HYPOT
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_HYPOT(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_HYPOT(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_HYPOT_F
  PURE SUBROUTINE MPFR_MUL_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_MUL(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_MUL
       END FUNCTION MPFR_MUL
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_MUL(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_MUL(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_MUL_F
  PURE SUBROUTINE MPFR_SUB_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SUB(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SUB
       END FUNCTION MPFR_SUB
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SUB(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_SUB(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SUB_F
  PURE SUBROUTINE MPFR_ADD_SI_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_ADD_SI(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_ADD_SI
       END FUNCTION MPFR_ADD_SI
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    INTEGER(KIND=c_long), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_ADD_SI(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_ADD_SI(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_ADD_SI_F
  PURE SUBROUTINE MPFR_DIV_SI_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_DIV_SI(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_DIV_SI
       END FUNCTION MPFR_DIV_SI
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    INTEGER(KIND=c_long), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_DIV_SI(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_DIV_SI(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_DIV_SI_F
  PURE SUBROUTINE MPFR_MUL_SI_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_MUL_SI(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_MUL_SI
       END FUNCTION MPFR_MUL_SI
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    INTEGER(KIND=c_long), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_MUL_SI(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_MUL_SI(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_MUL_SI_F
  PURE SUBROUTINE MPFR_SUB_SI_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SUB_SI(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SUB_SI
       END FUNCTION MPFR_SUB_SI
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    INTEGER(KIND=c_long), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SUB_SI(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_SUB_SI(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SUB_SI_F
  PURE SUBROUTINE MPFR_SI_DIV_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SI_DIV(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP2
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP1
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SI_DIV
       END FUNCTION MPFR_SI_DIV
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    INTEGER(KIND=c_long), INTENT(IN) :: OP1
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SI_DIV(C_LOC(ROP), OP1, C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_SI_DIV(C_LOC(ROP), OP1, C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SI_DIV_F
  PURE SUBROUTINE MPFR_SI_SUB_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SI_SUB(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP2
         INTEGER(KIND=c_long), INTENT(IN), VALUE :: OP1
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SI_SUB
       END FUNCTION MPFR_SI_SUB
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    INTEGER(KIND=c_long), INTENT(IN) :: OP1
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SI_SUB(C_LOC(ROP), OP1, C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_SI_SUB(C_LOC(ROP), OP1, C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SI_SUB_F
  PURE SUBROUTINE MPFR_ADD_D_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_ADD_D(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_ADD_D
       END FUNCTION MPFR_ADD_D
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    REAL(KIND=REAL64), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_ADD_D(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_ADD_D(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_ADD_D_F
  PURE SUBROUTINE MPFR_DIV_D_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_DIV_D(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_DIV_D
       END FUNCTION MPFR_DIV_D
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    REAL(KIND=REAL64), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_DIV_D(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_DIV_D(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_DIV_D_F
  PURE SUBROUTINE MPFR_MUL_D_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_MUL_D(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_MUL_D
       END FUNCTION MPFR_MUL_D
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    REAL(KIND=REAL64), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_MUL_D(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_MUL_D(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_MUL_D_F
  PURE SUBROUTINE MPFR_SUB_D_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_SUB_D(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP2
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_SUB_D
       END FUNCTION MPFR_SUB_D
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1
    REAL(KIND=REAL64), INTENT(IN) :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_SUB_D(C_LOC(ROP), C_LOC(OP1), OP2, RND)
       ELSE ! default rounding
          INFO = MPFR_SUB_D(C_LOC(ROP), C_LOC(OP1), OP2, MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_SUB_D_F
  PURE SUBROUTINE MPFR_D_DIV_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_D_DIV(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP2
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP1
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_D_DIV
       END FUNCTION MPFR_D_DIV
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    REAL(KIND=REAL64), INTENT(IN) :: OP1
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_D_DIV(C_LOC(ROP), OP1, C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_D_DIV(C_LOC(ROP), OP1, C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_D_DIV_F
  PURE SUBROUTINE MPFR_D_SUB_F(ROP, OP1, OP2, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_D_SUB(ROP, OP1, OP2, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP2
         REAL(KIND=c_double), INTENT(IN), VALUE :: OP1
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_D_SUB
       END FUNCTION MPFR_D_SUB
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    REAL(KIND=REAL64), INTENT(IN) :: OP1
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP2
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_D_SUB(C_LOC(ROP), OP1, C_LOC(OP2), RND)
       ELSE ! default rounding
          INFO = MPFR_D_SUB(C_LOC(ROP), OP1, C_LOC(OP2), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_D_SUB_F
  PURE SUBROUTINE MPFR_FMA_F(ROP, OP1, OP2, OP3, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_FMA(ROP, OP1, OP2, OP3, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2, OP3
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_FMA
       END FUNCTION MPFR_FMA
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2, OP3
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP3%TAG .EQ. TAG_NULL) INFO = -5_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_FMA(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), C_LOC(OP3), RND)
       ELSE ! default rounding
          INFO = MPFR_FMA(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), C_LOC(OP3), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_FMA_F
  PURE SUBROUTINE MPFR_FMS_F(ROP, OP1, OP2, OP3, RND, I)
    IMPLICIT NONE
    INTERFACE
       PURE FUNCTION MPFR_FMS(ROP, OP1, OP2, OP3, RND) BIND(C)
         IMPORT
         IMPLICIT NONE
         TYPE(c_ptr), INTENT(IN), VALUE :: ROP, OP1, OP2, OP3
         INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), VALUE :: RND
         INTEGER(KIND=c_int) :: MPFR_FMS
       END FUNCTION MPFR_FMS
    END INTERFACE
    TYPE(MPFR_T), INTENT(INOUT), TARGET :: ROP
    TYPE(MPFR_T), INTENT(IN), TARGET :: OP1, OP2, OP3
    INTEGER(KIND=MPFR_RND_KIND), INTENT(IN), OPTIONAL :: RND
    INTEGER, INTENT(OUT), OPTIONAL :: I
    INTEGER(KIND=c_int) :: INFO
    INFO = 0_c_int
    IF (OP3%TAG .EQ. TAG_NULL) INFO = -5_c_int
    IF (OP2%TAG .EQ. TAG_NULL) INFO = -4_c_int
    IF (OP1%TAG .EQ. TAG_NULL) INFO = -3_c_int
    IF (ROP%TAG .EQ. TAG_NULL) INFO = -2_c_int
    IF (INFO .EQ. 0_c_int) THEN
       IF (PRESENT(RND)) THEN
          INFO = MPFR_FMS(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), C_LOC(OP3), RND)
       ELSE ! default rounding
          INFO = MPFR_FMS(C_LOC(ROP), C_LOC(OP1), C_LOC(OP2), C_LOC(OP3), MPFR_RND_DEFAULT)
       END IF
    END IF
    IF (PRESENT(I)) I = INT(INFO)
  END SUBROUTINE MPFR_FMS_F
END MODULE MPFR_F
