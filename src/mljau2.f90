SUBROUTINE MLJAU2(A11, A22, A21, CS, SN, INFO)
  USE MPFR_F
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
  INTEGER, PARAMETER :: K = REAL64
  REAL(KIND=K), PARAMETER :: ZERO = 0.0_K, ONE = 1.0_K, TWO = 2.0_K
  TYPE(MPFR_T), INTENT(INOUT) :: A11, A22
  TYPE(MPFR_T), INTENT(IN) :: A21
  TYPE(MPFR_T), INTENT(OUT) :: CS, SN
  INTEGER, INTENT(INOUT) :: INFO
  TYPE(MPFR_T) :: AA, T2, T1
  INTEGER(KIND=MPFR_PREC_KIND) :: A21P
  CALL MPFR_INIT_M(AA, A21%MPFR_PREC)
  A21P = MAX(CS%MPFR_PREC, SN%MPFR_PREC)
  CALL MPFR_INIT_M(T2, A21P)
  CALL MPFR_INIT_M(T1, A21P)
  CS = ONE
  SN = ZERO
  IF (A21 .GT. SN) THEN
     A21P =  1_MPFR_PREC_KIND
  ELSE IF (A21 .LT. SN) THEN
     A21P = -1_MPFR_PREC_KIND
  ELSE ! A21 zero
     A21P =  0_MPFR_PREC_KIND
     INFO = IOR(INFO, 4)
     RETURN
  END IF
  CALL MPFR_ABS_F(AA, A21, MPFR_RNDN)
  IF (A11 .EQ. A22) THEN
     T1 = CS
  ELSE ! the general case
     CALL MPFR_SUB_F(T2, A11, A22, MPFR_RNDN)
     CALL MPFR_MUL_D_F(T1, AA, TWO, MPFR_RNDN)
     CALL MPFR_DIV_F(T2, T1, T2, MPFR_RNDN)
     CALL MPFR_HYPOT_F(T1, T2, CS, MPFR_RNDN)
     CALL MPFR_ADD_F(T1, T1, CS, MPFR_RNDN)
     CALL MPFR_DIV_F(T1, T2, T1, MPFR_RNDN)
  END IF
  CALL MPFR_HYPOT_F(CS, T1, CS, MPFR_RNDN)
  CALL MPFR_D_DIV_F(CS, ONE, CS, MPFR_RNDN)
  CALL MPFR_NEG_F(SN, T1, MPFR_RNDN)
  CALL MPFR_FMA_F(A11, T1, AA, A11, MPFR_RNDN)
  CALL MPFR_FMA_F(A22, SN, AA, A22, MPFR_RNDN)
  IF (A21P .GT. 0_MPFR_PREC_KIND) CALL MPFR_SET_M(SN, T1, MPFR_RNDN)
  CALL MPFR_CLEAR(T1)
  CALL MPFR_CLEAR(T2)
  CALL MPFR_CLEAR(AA)
END SUBROUTINE MLJAU2
