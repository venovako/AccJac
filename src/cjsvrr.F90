PROGRAM CJSVRR
#ifdef __GFORTRAN__
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, REAL32
#else
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT, REAL32, REAL128
#endif
  IMPLICIT NONE
  INTERFACE
     PURE FUNCTION XFMA(A, B, C)
#ifdef __GFORTRAN__
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
#else
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL128
#endif
       IMPLICIT NONE
#ifdef __GFORTRAN__
       REAL(KIND=c_long_double), INTENT(IN) :: A, B, C
       REAL(KIND=c_long_double) :: XFMA
#else
       REAL(KIND=REAL128), INTENT(IN) :: A, B, C
       REAL(KIND=REAL128) :: XFMA
#endif
     END FUNCTION XFMA
  END INTERFACE
  INTERFACE
     PURE FUNCTION WFMA(A, B, C)
#ifdef __GFORTRAN__
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
#else
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL128
#endif
       IMPLICIT NONE
#ifdef __GFORTRAN__
       COMPLEX(KIND=c_long_double), INTENT(IN) :: A, B, C
       COMPLEX(KIND=c_long_double) :: WFMA
#else
       COMPLEX(KIND=REAL128), INTENT(IN) :: A, B, C
       COMPLEX(KIND=REAL128) :: WFMA
#endif
     END FUNCTION WFMA
  END INTERFACE
#ifdef __GFORTRAN__
  INTERFACE
     PURE FUNCTION CR_HYPOT(X, Y) BIND(C,NAME='cr_hypotl')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
       IMPLICIT NONE
       REAL(KIND=c_long_double), INTENT(IN), VALUE :: X, Y
       REAL(KIND=c_long_double) :: CR_HYPOT
     END FUNCTION CR_HYPOT
  END INTERFACE
  INTEGER, PARAMETER :: KK = c_long_double
#else
#define CR_HYPOT HYPOT
  INTEGER, PARAMETER :: KK = REAL128
#endif
  INTEGER, PARAMETER :: K = REAL32
  REAL(KIND=KK), PARAMETER :: XZERO = 0.0_KK
  CHARACTER(LEN=256) :: CLA
  COMPLEX(KIND=K), ALLOCATABLE :: G(:,:), V(:,:), U(:,:)
  REAL(KIND=K), ALLOCATABLE :: S(:)
  COMPLEX(KIND=KK), ALLOCATABLE :: XG(:,:), XV(:,:), XU(:,:)
  REAL(KIND=KK), ALLOCATABLE :: XS(:,:)
  REAL(KIND=KK) :: X
  INTEGER :: M, N, I, J, L
  EXTERNAL :: BFOPEN
  I = COMMAND_ARGUMENT_COUNT()
  IF (I .NE. 3) STOP 'cjsvrr.exe M N FN'
  CALL GET_COMMAND_ARGUMENT(1, CLA)
  READ (CLA,*) M
  IF (M .LE. 0) STOP 'M'
  CALL GET_COMMAND_ARGUMENT(2, CLA)
  READ (CLA,*) N
  IF ((N .LE. 0) .OR. (N .GT. M)) STOP 'N'
  CALL GET_COMMAND_ARGUMENT(3, CLA)
  CALL BFOPEN(TRIM(CLA)//'.Y', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(Y)'
  ALLOCATE(G(M,N))
  READ (UNIT=I, IOSTAT=J) G
  IF (J .NE. 0) STOP 'READ(Y)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(Y)'
  CALL BFOPEN(TRIM(CLA)//'.YV', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YV)'
  ALLOCATE(V(N,N))
  READ (UNIT=I, IOSTAT=J) V
  IF (J .NE. 0) STOP 'READ(YV)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YV)'
  CALL BFOPEN(TRIM(CLA)//'.YU', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YU)'
  ALLOCATE (U(M,N))
  READ (UNIT=I, IOSTAT=J) U
  IF (J .NE. 0) STOP 'READ(YU)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YU)'
  CALL BFOPEN(TRIM(CLA)//'.SY', 'RO', I, J)
  IF (J .NE. 0) STOP 'READ(SY)'
  ALLOCATE(S(N))
  READ (UNIT=I, IOSTAT=J) S
  IF (J .NE. 0) STOP 'READ(SY)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(SY)'
  ALLOCATE(XG(M,N))
  ALLOCATE(XV(N,N))
  ALLOCATE(XU(M,N))
  ALLOCATE(XS(N,2))
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(G,XG,M,N)
  DO J = 1, N
     DO I = 1, M
        XG(I,J) = G(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(V,XV,N)
  DO J = 1, N
     DO I = 1, N
        XV(I,J) = V(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(XU,M,N)
  DO J = 1, N
     DO I = 1, M
        XU(I,J) = XZERO
     END DO
  END DO
  !$OMP END PARALLEL DO
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(XG,XU,XV,M,N)
  DO J = 1, N
     DO L = 1, N
        DO I = 1, M
           XU(I,J) = WFMA(XG(I,L), XV(L,J), XU(I,J))
        END DO
     END DO
  END DO
  !$OMP END PARALLEL DO
  WRITE (OUTPUT_UNIT,'(A)') '"j", "||(G*V)j - (U*Σ)j||_F / Σj"'
  FLUSH(OUTPUT_UNIT)
  X = XZERO
  L = 0
  DO J = 1, N
     XS(J,1) = S(J)
     XS(J,2) = XZERO
     DO I = 1, M
        XU(I,J) = CMPLX(XFMA(REAL(-REAL(U(I,J)), KK), XS(J,1), REAL(XU(I,J))),&
             XFMA(REAL(-AIMAG(U(I,J)), KK), XS(J,1), AIMAG(XU(I,J))), KK)
        XS(J,2) = CR_HYPOT(XS(J,2), CR_HYPOT(REAL(XU(I,J)), AIMAG(XU(I,J))))
     END DO
     XS(J,2) = XS(J,2) / XS(J,1)
     WRITE (OUTPUT_UNIT,'(I11,A,ES16.9E2)') J, ',', REAL(XS(J,2), K)
     FLUSH(OUTPUT_UNIT)
     IF (XS(J,2) .GT. X) THEN
        X = XS(J,2)
        L = J
     END IF
  END DO
  WRITE (OUTPUT_UNIT,'(I11,A,ES16.9E2)') -L, ',', REAL(X, K)
  FLUSH(OUTPUT_UNIT)
  DEALLOCATE(XS)
  DEALLOCATE(XU)
  DEALLOCATE(XV)
  DEALLOCATE(XG)
  DEALLOCATE(S)
  DEALLOCATE(U)
  DEALLOCATE(V)
  DEALLOCATE(G)
END PROGRAM CJSVRR
