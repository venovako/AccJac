PROGRAM CJSVDX
#ifdef __GFORTRAN__
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long, c_long_double
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64, OUTPUT_UNIT, REAL32
#else
  USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64, OUTPUT_UNIT, REAL32, REAL128
#endif
#ifdef USE_IEEE_INTRINSIC
  USE, INTRINSIC :: IEEE_ARITHMETIC, ONLY: IEEE_FMA
#endif
  IMPLICIT NONE
#ifdef USE_IEEE_INTRINSIC
#define XFMA IEEE_FMA
#else
  INTERFACE
#ifdef __GFORTRAN__
     PURE FUNCTION XFMA(A, B, C) BIND(C,NAME='fmal')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
#else
     PURE FUNCTION XFMA(A, B, C) BIND(C,NAME='__fmaq')
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL128
#endif
       IMPLICIT NONE
#ifdef __GFORTRAN__
       REAL(KIND=c_long_double), INTENT(IN), VALUE :: A, B, C
       REAL(KIND=c_long_double) :: XFMA
#else
       REAL(KIND=REAL128), INTENT(IN), VALUE :: A, B, C
       REAL(KIND=REAL128) :: XFMA
#endif
     END FUNCTION XFMA
  END INTERFACE
#endif
#ifdef __GFORTRAN__
#define WFMA(A,B,C) CMPLX(XFMA(REAL(A),REAL(B),XFMA(-AIMAG(A),AIMAG(B),REAL(C))),XFMA(REAL(A),AIMAG(B),XFMA(AIMAG(A),REAL(B),AIMAG(C))),c_long_double)
  INTERFACE
     PURE FUNCTION HYPOTX(X, Y) BIND(C,NAME='cr_hypotl')
       USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_long_double
       IMPLICIT NONE
       REAL(KIND=c_long_double), INTENT(IN), VALUE :: X, Y
       REAL(KIND=c_long_double) :: HYPOTX
     END FUNCTION HYPOTX
  END INTERFACE
#else
#define WFMA(A,B,C) CMPLX(XFMA(REAL(A),REAL(B),XFMA(-AIMAG(A),AIMAG(B),REAL(C))),XFMA(REAL(A),AIMAG(B),XFMA(AIMAG(A),REAL(B),AIMAG(C))),REAL128)
#define HYPOTX HYPOT
#endif
  INTEGER, PARAMETER :: K = REAL32
  CHARACTER(LEN=256) :: CLA
  COMPLEX(KIND=K) :: T
  REAL(KIND=K) :: R
  INTEGER(KIND=INT64) :: CLK(3)
  INTEGER :: M, N, LDG, LDV, JPOS, GS, INFO, I, J, L
  COMPLEX(KIND=K), ALLOCATABLE :: G(:,:), V(:,:), WRK(:,:)
  REAL(KIND=K), ALLOCATABLE :: SV(:), LY(:)
  INTEGER, ALLOCATABLE :: IX(:)
  EXTERNAL :: BFOPEN, CJSVDF
  ! read the command line arguments
  I = COMMAND_ARGUMENT_COUNT()
  IF (I .NE. 5) STOP 'cjsvdx.exe M N JPOS OPTS FILE'
  CALL GET_COMMAND_ARGUMENT(1, CLA)
  READ (CLA,*) M
  IF (M .LE. 0) STOP 'M'
  CALL GET_COMMAND_ARGUMENT(2, CLA)
  READ (CLA,*) N
  IF ((N .LE. 0) .OR. (N .GT. M)) STOP 'N'
  CALL GET_COMMAND_ARGUMENT(3, CLA)
  READ (CLA,*) JPOS
  IF ((JPOS .LT. 0) .OR. (JPOS .GT. N)) STOP 'JPOS'
  CALL GET_COMMAND_ARGUMENT(4, CLA)
  READ (CLA,*) L
  IF (L .LT. 0) STOP 'OPTS'
  CALL GET_COMMAND_ARGUMENT(5, CLA)
  IF (LEN_TRIM(CLA) .LE. 0) STOP 'FILE'
  ! set G
  LDG = M
  ALLOCATE(G(LDG,N))
  CALL BFOPEN(TRIM(CLA)//'.Y', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(Y)'
  READ (UNIT=I, IOSTAT=J) G
  IF (J .NE. 0) STOP 'READ(Y)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(Y)'
  ! allocate the rest
  LDV = N
  ALLOCATE(V(LDV,N))
  ALLOCATE(WRK(M,N))
  ALLOCATE(SV(N))
  ALLOCATE(LY(N))
  ALLOCATE(IX(N))
  ! call CJSVDF
  GS = HUGE(GS)
  INFO = IAND(L, 1)
  IX(1) = ISHFT(IAND(L, 6), -1)
  CALL SYSTEM_CLOCK(CLK(1), CLK(2), CLK(3))
  CALL CJSVDF(M, N, G, LDG, V, LDV, JPOS, SV, GS, IX, WRK, LY, INFO)
  CALL SYSTEM_CLOCK(CLK(3))
  CLK(1) = CLK(3) - CLK(1)
  CLK(3) = MOD(CLK(1), CLK(2)) * 1000000_INT64
  CLK(1) = CLK(1) / CLK(2)
  CLK(3) = CLK(3) / CLK(2)
  R = LY(N)
  CLK(2) = INT(R, INT64)
  WRITE (OUTPUT_UNIT,'(I11,A,I12,A,I6,A,I8,A,I6.6)') INFO, ',', CLK(2), ',', GS, ',', CLK(1), '.', CLK(3)
  FLUSH(OUTPUT_UNIT)
  IF (INFO .LT. 0) STOP 'CJSVDF'
  CALL BFOPEN(TRIM(CLA)//'.YU', 'WO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YU)'
  WRITE (UNIT=I, IOSTAT=J) G
  IF (J .NE. 0) STOP 'WRITE(YU)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YU)'
  CALL BFOPEN(TRIM(CLA)//'.YV', 'WO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YV)'
  WRITE (UNIT=I, IOSTAT=J) V
  IF (J .NE. 0) STOP 'WRITE(YV)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YV)'
  CALL BFOPEN(TRIM(CLA)//'.SS', 'WO', I, J)
  IF (J .NE. 0) STOP 'OPEN(SS)'
  WRITE (UNIT=I, IOSTAT=J) SV
  IF (J .NE. 0) STOP 'WRITE(SS)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(SS)'
  ! V^-1 = J V^H J
  DO J = 1, N
     DO I = 1, J-1
        T = V(I,J)
        V(I,J) = CONJG(V(J,I))
        V(J,I) = CONJG(T)
     END DO
     V(J,J) = CONJG(V(J,J))
  END DO
  DO J = 1, JPOS
     DO I = JPOS+1, N
        V(I,J) = -V(I,J)
     END DO
  END DO
  DO J = JPOS+1, N
     DO I = 1, JPOS
        V(I,J) = -V(I,J)
     END DO
  END DO
  CALL BFOPEN(TRIM(CLA)//'.ZZ', 'WO', I, J)
  IF (J .NE. 0) STOP 'OPEN(ZZ)'
  WRITE (UNIT=I, IOSTAT=J) V
  IF (J .NE. 0) STOP 'WRITE(ZZ)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(ZZ)'
  L = -GS
  DO J = 1, N
     SV(J) = SCALE(SV(J), L)
  END DO
  CALL BFOPEN(TRIM(CLA)//'.SY', 'WO', I, J)
  IF (J .NE. 0) STOP 'OPEN(SY)'
  WRITE (UNIT=I, IOSTAT=J) SV
  IF (J .NE. 0) STOP 'WRITE(SY)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(SY)'
  IF (ALLOCATED(IX)) DEALLOCATE(IX)
  IF (ALLOCATED(LY)) DEALLOCATE(LY)
  IF (ALLOCATED(SV)) DEALLOCATE(SV)
  IF (ALLOCATED(WRK)) DEALLOCATE(WRK)
  IF (ALLOCATED(V)) DEALLOCATE(V)
  IF (ALLOCATED(G)) DEALLOCATE(G)
END PROGRAM CJSVDX
