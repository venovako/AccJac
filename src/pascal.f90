#ifdef _OPENMP
SUBROUTINE PASCAL(N, L, U, S, INFO)
#else
PURE SUBROUTINE PASCAL(N, L, U, S, INFO)
#endif
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
  IMPLICIT NONE
  INTERFACE
#ifdef _OPENMP
     SUBROUTINE JMMMSQ(M, N, A, LDA, B, LDB, C, LDC)
#else
     PURE SUBROUTINE JMMMSQ(M, N, A, LDA, B, LDB, C, LDC)
#endif
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: INT64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M, N, LDA, LDB, LDC
       INTEGER(KIND=INT64), INTENT(IN) :: A(LDA,M), B(LDB,N)
       INTEGER(KIND=INT64), INTENT(INOUT) :: C(LDC,N)
     END SUBROUTINE JMMMSQ
  END INTERFACE
  INTEGER, INTENT(IN) :: N
  INTEGER(KIND=INT64), INTENT(OUT) :: L(N,N), U(N,N), S(N,N)
  INTEGER, INTENT(OUT) :: INFO
  INTEGER :: I, J
  INFO = 0
  IF (N .LT. 0) INFO = -1
  IF (INFO .NE. 0) RETURN
  IF (N .EQ. 0) RETURN
  L(1,1) = 1_INT64
  DO I = 2, N
     L(I,1) = 1_INT64
     L(I,I) = 1_INT64
  END DO
  DO J = 2, N
     DO I = 1, J-1
        L(I,J) = 0_INT64
     END DO
     DO I = J+1, N
        L(I,J) = L(I-1,J-1) + L(I-1,J)
     END DO
  END DO
  DO J = 1, N
     DO I = 1, N
        U(I,J) = L(J,I)
     END DO
  END DO
  DO J = 1, N
     DO I = 1, N
        S(I,J) = 0_INT64
     END DO
  END DO
  CALL JMMMSQ(N, N, L, N, U, N, S, N)
END SUBROUTINE PASCAL
