! IN: INFO & 1: sin => tan
!     INFO & 2: hyp
!OUT: INFO = 0: notransf (convergence criterion)
!     INFO = 1: transf (but identity, so no-op)
!     INFO = 2: transf, no downscaling of G and SV
!     INFO = 3: transf with downscaling of G and SV
SUBROUTINE DTRANS(M, N, G, LDG, V, LDV, SV, GX, GS, P, Q, TOL, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
  INTERFACE
     FUNCTION DSDP(M, X, Y, MX, MY, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M
       REAL(KIND=REAL64), INTENT(IN) :: X(M), Y(M), MX, MY
       INTEGER, INTENT(OUT) :: INFO
       REAL(KIND=REAL64) :: DSDP
     END FUNCTION DSDP
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DGRAM(PNF, QNF, QPS, APP, AQQ, AQP, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       REAL(KIND=REAL64), INTENT(IN) :: PNF, QNF, QPS
       REAL(KIND=REAL64), INTENT(OUT) :: APP, AQQ, AQP
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE DGRAM
  END INTERFACE
  INTERFACE
     SUBROUTINE DLJU2(A11, A22, A21, CS, SN, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       REAL(KIND=REAL64), INTENT(IN) :: A11, A22, A21
       REAL(KIND=REAL64), INTENT(OUT) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DLJU2
  END INTERFACE
  INTERFACE
     SUBROUTINE DLJV2(A11, A22, A21, CH, SH, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       REAL(KIND=REAL64), INTENT(IN) :: A11, A22, A21
       REAL(KIND=REAL64), INTENT(OUT) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DLJV2
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTVT(M, X, Y, CS, SN, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M
       REAL(KIND=REAL64), INTENT(INOUT) :: X(M), Y(M)
       REAL(KIND=REAL64), INTENT(IN) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTVT
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTVH(M, X, Y, CH, SH, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M
       REAL(KIND=REAL64), INTENT(INOUT) :: X(M), Y(M)
       REAL(KIND=REAL64), INTENT(IN) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTVH
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DROTT(M, X, Y, CS, SN, GX, MX, MY, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M
       REAL(KIND=REAL64), INTENT(INOUT) :: X(M), Y(M), GX, MX, MY
       REAL(KIND=REAL64), INTENT(IN) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DROTT
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DROTH(M, X, Y, CH, SH, GX, MX, MY, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M
       REAL(KIND=REAL64), INTENT(INOUT) :: X(M), Y(M), GX, MX, MY
       REAL(KIND=REAL64), INTENT(IN) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DROTH
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DSCALG(M, N, G, LDG, GX, GS, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: M, N, LDG
       REAL(KIND=REAL64), INTENT(INOUT) :: G(LDG,N), GX
       INTEGER, INTENT(INOUT) :: GS, INFO
     END SUBROUTINE DSCALG
  END INTERFACE
  INTEGER, PARAMETER :: K = REAL64
  REAL(KIND=K), PARAMETER :: ZERO = 0.0_K
  INTEGER, INTENT(IN) :: M, N, LDG, LDV, P, Q
  REAL(KIND=K), INTENT(INOUT) :: G(LDG,N), V(LDV,N), SV(N), GX
  REAL(KIND=K), INTENT(IN) :: TOL
  INTEGER, INTENT(INOUT) :: GS, INFO
  REAL(KIND=K) :: QPS, APP, AQQ, AQP, C, S, T
  INTEGER :: I, J
  IF ((INFO .LT. 0) .OR. (INFO .GT. 3)) INFO = -13
  IF (TOL .LT. ZERO) INFO = -12
  IF ((Q .LE. P) .OR. (Q .GT. N)) INFO = -11
  IF ((P .LE. 0) .OR. (P .GT. N)) INFO = -10
  IF (LDV .LT. N) INFO = -6
  IF (LDG .LT. M) INFO = -4
  IF ((N .LT. 0) .OR. (N .GT. M)) INFO = -2
  IF (M .LT. 0) INFO = -1
  IF (INFO .LT. 0) RETURN
  IF (M .EQ. 0) RETURN
  I = 0
  QPS = DSDP(M, G(1,Q), G(1,P), SV(Q), SV(P), I)
  IF (I .NE. 0) THEN
     INFO = -3
     RETURN
  END IF
  T = ABS(QPS)
  IF (.NOT. (T .LE. HUGE(T))) THEN
     INFO = -3
     RETURN
  END IF
  I = INFO
  IF (T .LT. TOL) THEN
     INFO = 0
     RETURN
  ELSE ! transform
     INFO = 2
  END IF
  J = 0
  CALL DGRAM(SV(P), SV(Q), QPS, APP, AQQ, AQP, J)
  IF (J .LE. -HUGE(J)) THEN
     INFO = -7
     RETURN
  END IF
  J = IAND(I, 2)
  I = IAND(I, 1)
  T = GX
  IF (J .EQ. 0) THEN
     CALL DLJU2(APP, AQQ, AQP, C, S, I)
     J = I
     CALL DROTT(M, G(1,P), G(1,Q), C, S, T, SV(P), SV(Q), J)
     IF (J .EQ. 0) CALL DRTVT(N, V(1,P), V(1,Q), C, S, I)
     I = J
  ELSE ! hyp
     CALL DLJV2(APP, AQQ, AQP, C, S, I)
     J = I
     CALL DROTH(M, G(1,P), G(1,Q), C, S, T, SV(P), SV(Q), J)
     IF (J .EQ. 0) CALL DRTVH(N, V(1,P), V(1,Q), C, S, I)
     I = J
  END IF
  IF (I .NE. 0) THEN
     IF (I .LT. 0) THEN
        INFO = -8
     ELSE ! no-op
        INFO = 1
     END IF
     RETURN
  END IF
  IF (T .GT. GX) THEN
     GX = T
     I = 1
     CALL DSCALG(M, N, G, LDG, GX, GS, I)
     IF (I .LT. 0) THEN
        INFO = -9
        RETURN
     END IF
     IF (I .GT. 0) THEN
        I = -I
        DO J = 1, N
           SV(J) = SCALE(SV(J), I)
        END DO
        INFO = 3
     END IF
  END IF
END SUBROUTINE DTRANS
