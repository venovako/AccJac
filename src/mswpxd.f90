PURE SUBROUTINE MSWPXD(N, A, LDA, V, LDV, B, E, INFO)
  USE MPFR_F
  IMPLICIT NONE
  INTERFACE
     PURE SUBROUTINE MSWPC(N, A, LDA, P, Q, INFO)
       USE MPFR_F
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       TYPE(MPFR_T), INTENT(INOUT) :: A(LDA,N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE MSWPC
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE MSWPR(N, A, LDA, P, Q, INFO)
       USE MPFR_F
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       TYPE(MPFR_T), INTENT(INOUT) :: A(LDA,N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE MSWPR
  END INTERFACE
  INTEGER, INTENT(IN) :: N, LDA, LDV, B, E
  TYPE(MPFR_T), INTENT(INOUT) :: A(LDA,N), V(LDV,N)
  INTEGER, INTENT(OUT) :: INFO
  TYPE(MPFR_T) :: X, T
  INTEGER :: J
  INFO = 0
  IF ((E .LE. 0) .OR. (E .GT. N)) INFO = -7
  IF ((B .LE. 0) .OR. (B .GT. E)) INFO = -6
  IF (LDV .LE. 0) INFO = -5
  IF (LDA .LE. 0) INFO = -3
  IF ((N .LE. 0) .OR. (N .GT. MIN(LDV, LDA))) INFO = -1
  IF (INFO .NE. 0) RETURN
  CALL MPFR_INIT_M(X)
  CALL MPFR_INIT_M(T)
  CALL MPFR_SET_ZERO(X, X%TAG)
  INFO = B
  DO J = B, E
     CALL MPFR_ABS_F(T, A(J,J))
     IF (T .GT. X) THEN
        CALL MPFR_SWAP_M(X, T)
        INFO = J
     END IF
  END DO
  IF (INFO .GT. B) THEN
     DO J = 1, N
        CALL MPFR_SWAP_M(V(J,B), V(J,INFO))
     END DO
     CALL MSWPC(N, A, LDA, B, INFO, J)
     IF (J .NE. 0) THEN
        INFO = -2
        RETURN
     END IF
     CALL MSWPR(N, A, LDA, B, INFO, J)
     IF (J .NE. 0) THEN
        INFO = -4
        RETURN
     END IF
  END IF
  CALL MPFR_CLEAR_M(T)
  CALL MPFR_CLEAR_M(X)
END SUBROUTINE MSWPXD
