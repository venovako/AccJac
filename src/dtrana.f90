! IN: INFO & 1: sin => tan
!     INFO & 2: hyp
!OUT: INFO = 0: notransf
!     INFO = 1: swap only
!     INFO = 2: transf, no downscaling of A
!     INFO = 3: transf with downscaling of A
SUBROUTINE DTRANA(N, A, LDA, V, LDV, AX, AS, P, Q, TOL, INFO)
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
  IMPLICIT NONE
  INTERFACE
     SUBROUTINE DSWPC(N, A, LDA, P, Q, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE DSWPC
  END INTERFACE
  INTERFACE
     SUBROUTINE DSWPR(N, A, LDA, P, Q, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N)
       INTEGER, INTENT(OUT) :: INFO
     END SUBROUTINE DSWPR
  END INTERFACE
  INTERFACE
     SUBROUTINE DLJAU2(A11, A22, A21, CS, SN, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       REAL(KIND=REAL64), INTENT(INOUT) :: A11, A22
       REAL(KIND=REAL64), INTENT(IN) :: A21
       REAL(KIND=REAL64), INTENT(OUT) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DLJAU2
  END INTERFACE
  INTERFACE
     SUBROUTINE DLJAV2(A11, A22, A21, CH, SH, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       REAL(KIND=REAL64), INTENT(INOUT) :: A11, A22
       REAL(KIND=REAL64), INTENT(IN) :: A21
       REAL(KIND=REAL64), INTENT(OUT) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DLJAV2
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTLT(N, A, LDA, AX, P, Q, CS, SN, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N), AX
       REAL(KIND=REAL64), INTENT(IN) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTLT
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTLH(N, A, LDA, AX, P, Q, CH, SH, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N), AX
       REAL(KIND=REAL64), INTENT(IN) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTLH
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTRT(N, A, LDA, AX, P, Q, CS, SN, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N), AX
       REAL(KIND=REAL64), INTENT(IN) :: CS, SN
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTRT
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DRTRH(N, A, LDA, AX, P, Q, CH, SH, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA, P, Q
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N), AX
       REAL(KIND=REAL64), INTENT(IN) :: CH, SH
       INTEGER, INTENT(INOUT) :: INFO
     END SUBROUTINE DRTRH
  END INTERFACE
  INTERFACE
     PURE SUBROUTINE DSCALA(N, A, LDA, AX, AS, INFO)
       USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: REAL64
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: N, LDA
       REAL(KIND=REAL64), INTENT(INOUT) :: A(LDA,N), AX
       INTEGER, INTENT(INOUT) :: AS, INFO
     END SUBROUTINE DSCALA
  END INTERFACE
  INTEGER, PARAMETER :: K = REAL64
  REAL(KIND=K), PARAMETER :: ZERO = 0.0_K
  INTEGER, INTENT(IN) :: N, LDA, LDV, P, Q
  REAL(KIND=K), INTENT(INOUT) :: A(LDA,N), V(LDV,N), AX, TOL
  INTEGER, INTENT(INOUT) :: AS, INFO
  REAL(KIND=K) :: A1, A2, VX, C, S, T
  INTEGER :: I
  IF ((INFO .LT. 0) .OR. (INFO .GT. 3)) INFO = -11
  IF (TOL .LT. ZERO) INFO = -10
  IF ((Q .LE. 0) .OR. (Q .GT. N)) INFO = -9
  IF ((P .LE. 0) .OR. (P .GT. N)) INFO = -8
  IF (AX .LT. ZERO) INFO = -6
  IF (LDV .LT. N) INFO = -5
  IF (LDA .LT. N) INFO = -3
  IF (N .LT. 0) INFO = -1
  IF (INFO .LT. 0) RETURN
  IF (N .EQ. 0) RETURN
  I = IAND(INFO, 2)
  A1 = A(P,P)
  A2 = A(Q,Q)
  T = (SQRT(ABS(A1)) * SQRT(ABS(A2))) * TOL
  TOL = ZERO
  IF (ABS(A(Q,P)) .LT. T) THEN
     IF ((I .EQ. 0) .AND. (A1 .LT. A2)) THEN
        CALL DSWPC(N, V, LDV, P, Q, INFO)
        CALL DSWPC(N, A, LDA, P, Q, INFO)
        CALL DSWPR(N, A, LDA, P, Q, INFO)
        INFO = 1
     ELSE ! no-op
        INFO = 0
     END IF
  ELSE ! rotate
     VX = ZERO
     T = AX
     IF (I .EQ. 0) THEN
        CALL DLJAU2(A1, A2, A(Q,P), C, S, INFO)
        CALL DRTRT(N, V, LDV, VX, P, Q, C, S, INFO)
        CALL DRTRT(N, A, LDA, AX, P, Q, C, S, INFO)
        CALL DRTLT(N, A, LDA, AX, P, Q, C, S, INFO)
     ELSE ! hyp
        CALL DLJAV2(A1, A2, A(Q,P), C, S, INFO)
        CALL DRTRH(N, V, LDV, VX, P, Q, C, S, INFO)
        CALL DRTRH(N, A, LDA, AX, P, Q, C, S, INFO)
        CALL DRTLH(N, A, LDA, AX, P, Q, C, S, INFO)
     END IF
     TOL = S
     IF (.NOT. (VX .LT. HUGE(VX))) THEN
        INFO = -4
        RETURN
     END IF
     IF (INFO .LT. 0) THEN
        INFO = -2
        RETURN
     END IF
     IF (IAND(INFO, 4) .NE. 0) THEN
        IF (IAND(INFO, 8) .EQ. 0) THEN
           I = 0
        ELSE ! swap
           I = 1
        END IF
     ELSE ! transf
        I = 2
     END IF
     A(P,P) = A1
     A(Q,Q) = A2
     IF (IAND(INFO, 2) .EQ. 0) THEN
        A(P,Q) = ZERO
        A(Q,P) = ZERO
     END IF
     IF (AX .GT. T) THEN
        INFO = 1
        CALL DSCALA(N, A, LDA, AX, AS, INFO)
        IF (INFO .LT. 0) THEN
           I = -7
        ELSE IF (INFO .GT. 0) THEN
           I = 3
        ELSE ! no downscaling
           I = 2
        END IF
     END IF
     INFO = I
  END IF
END SUBROUTINE DTRANA
