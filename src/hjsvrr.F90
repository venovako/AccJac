  I = COMMAND_ARGUMENT_COUNT()
  CALL GET_COMMAND_ARGUMENT(0, CLA)
  IF (I .NE. 3) STOP TRIM(CLA)//' M N FN'
  CALL GET_COMMAND_ARGUMENT(1, CLA)
  READ (CLA,*) M
  IF (M .LE. 0) STOP 'M'
  CALL GET_COMMAND_ARGUMENT(2, CLA)
  READ (CLA,*) N
  IF ((N .LE. 0) .OR. (N .GT. M)) STOP 'N'
  CALL GET_COMMAND_ARGUMENT(3, CLA)

  CALL BFOPEN(TRIM(CLA)//'.Y', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(Y)'
  ALLOCATE(G(M,N))
  READ (UNIT=I, IOSTAT=J) G
  IF (J .NE. 0) STOP 'READ(Y)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(Y)'

  CALL BFOPEN(TRIM(CLA)//'.ZZ', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(ZZ)'
  ALLOCATE(V(N,N))
  READ (UNIT=I, IOSTAT=J) V
  IF (J .NE. 0) STOP 'READ(ZZ)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(ZZ)'

  CALL BFOPEN(TRIM(CLA)//'.YU', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YU)'
  ALLOCATE (U(M,N))
  READ (UNIT=I, IOSTAT=J) U
  IF (J .NE. 0) STOP 'READ(YU)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YU)'

  CALL BFOPEN(TRIM(CLA)//'.SY', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(SY)'
  ALLOCATE(S(N))
  READ (UNIT=I, IOSTAT=J) S
  IF (J .NE. 0) STOP 'READ(SY)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(SY)'

  ALLOCATE(XG(M,N))
  ALLOCATE(XV(N,N))
  ALLOCATE(XU(M,N))
  ALLOCATE(XS(N))

  GN = XZERO
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(G,XG,M,N) REDUCTION(HYP:GN)
  DO J = 1, N
     DO I = 1, M
        XG(I,J) = G(I,J)
        GN = CR_HYPOT(GN, CR_HYPOT(REAL(XG(I,J)), AIMAG(XG(I,J))))
     END DO
  END DO
  !$OMP END PARALLEL DO

  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(V,XV,N)
  DO J = 1, N
     DO I = 1, N
        XV(I,J) = V(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO
  
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J,X) SHARED(U,S,XU,M,N)
  DO J = 1, N
     X = REAL(-S(J), KK)
     DO I = 1, M
        XU(I,J) = CMPLX(REAL(REAL(U(I,J)), KK) * X, REAL(AIMAG(U(I,J)), KK) * X, KK)
     END DO
  END DO
  !$OMP END PARALLEL DO

  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J,L) SHARED(XG,XU,XV,M,N)
  DO J = 1, N
     DO L = 1, N
        DO I = 1, M
           XG(I,J) = WFMA(XU(I,L), XV(L,J), XG(I,J))
        END DO
     END DO
  END DO
  !$OMP END PARALLEL DO

  X = XZERO
  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(G,XG,M,N) REDUCTION(HYP:X)
  DO J = 1, N
     DO I = 1, M
        X = CR_HYPOT(X, CR_HYPOT(REAL(XG(I,J)), AIMAG(XG(I,J))))
        XG(I,J) = G(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO
  IF (X .EQ. XZERO) THEN
     GN = X
  ELSE ! X .NE. XZERO
     GN = X / GN
  END IF

  CALL BFOPEN(TRIM(CLA)//'.YV', 'RO', I, J)
  IF (J .NE. 0) STOP 'OPEN(YV)'
  READ (UNIT=I, IOSTAT=J) V
  IF (J .NE. 0) STOP 'READ(YV)'
  CLOSE (UNIT=I, IOSTAT=J)
  IF (J .NE. 0) STOP 'CLOSE(YV)'

  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(V,XV,N)
  DO J = 1, N
     DO I = 1, N
        XV(I,J) = V(I,J)
     END DO
  END DO
  !$OMP END PARALLEL DO

  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(XG,XU,XV,M,N)
  DO J = 1, N
     DO L = 1, N
        DO I = 1, M
           XU(I,J) = WFMA(XG(I,L), XV(L,J), XU(I,J))
        END DO
     END DO
  END DO
  !$OMP END PARALLEL DO

  !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(I,J) SHARED(U,XU,S,XS,M,N)
  DO J = 1, N
     XS(J) = XZERO
     DO I = 1, M
        XS(J) = CR_HYPOT(XS(J), CR_HYPOT(REAL(XU(I,J)), AIMAG(XU(I,J))))
     END DO
     XS(J) = XS(J) / REAL(S(J), KK)
  END DO
  !$OMP END PARALLEL DO

  WRITE (OUTPUT_UNIT,'(A)') '"j", "||(G*V)j - (U*Σ)j||_F / Σj"'
  FLUSH(OUTPUT_UNIT)
  X = XZERO
  L = 0
  DO J = 1, N
     WRITE (OUTPUT_UNIT,9) J, ',', REAL(XS(J), K)
     FLUSH(OUTPUT_UNIT)
     IF (XS(J) .GT. X) THEN
        X = XS(J)
        L = J
     END IF
  END DO
  WRITE (OUTPUT_UNIT,9) -L, ',', REAL(X, K)
  FLUSH(OUTPUT_UNIT)
  WRITE (OUTPUT_UNIT,9) 0, ',', REAL(GN, K)
  FLUSH(OUTPUT_UNIT)

  DEALLOCATE(XS)
  DEALLOCATE(XU)
  DEALLOCATE(XV)
  DEALLOCATE(XG)
  DEALLOCATE(S)
  DEALLOCATE(U)
  DEALLOCATE(V)
  DEALLOCATE(G)
